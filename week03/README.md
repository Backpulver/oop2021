# Конструктори

## Видове конструктори
- Конструктор по подразбиране
- Конструктор с параметри
- Конструктор с параметри по подразбиране
- Конструктор за копиране
- Автоматично генерирани конструктори по подразбиране и за копиране

### Конструктор по подразбиране
Конструктор без параметри. Ако не е дефиниран нито един конструктор, автоматично се създава конструктор по подразбиране.

### Конструктор с параметри

### Конструктор с параметри по подразбиране
- Какво е функция с параметри по подразбиране?  
```c++
    Rational(int num = 0, int denom = 1); 
    //Rational(int num = 0, int denom); -- грешно!
```
- Възможни извиквания на така дефиниран конструктор
```c++
    Rational();
    Rational(5);
    Rational(5, 3);
```

### Инициализиращ списък (Member initializer list)

- задават се стойности на член-данните по време на тяхната дефиниция (преди тялото на конструктора).
Пример:
```c++
    Rational::Rational(int num, double denom) : numerator(num), denominator(denom) {}
```
- иначе първо се заделя паметта (извиква се конструктора по подразбиране за обекти) и след това се присвояват стойностите. 
Пример:
```c++
    Rational::Rational(int num, int denom) 
    {   
        this->numerator = num;
        this->denominator = denom;
    }
```
- позволява инициализация на константи. Пример:
    ```c++
        class Example {
            const int MY_CONST;
            int var;

        public:
            Example(int constValue, int Var) : MY_CONST(constValue), var(Var) {}
        }
    ```
    - защо следното няма да работи:
    ```c++
        Example(int constValue, int Var) : var(Var) {
                MY_CONST = constValue;
            }
    ```

### Конструктор за копиране
Използва се за създаване на обект като се използва за образец някой друг обект.
```c++
    MyClass::MyClass(MyClass const& rhs): var(rhs.var) {}
    Rational::Rational(Rational const& rhs): numerator(rhs.numerator), denominator(rhs.denominator) {}
```

Извикване на конструктор за копиране:
```c++
    MyClass a;
    MyClass b = a;
    MyClass c(a);
```

Както и при конструктора по подразбиране, ако не е написан конструктор за копиране създава се автоматично такъв, който копира член-данните.

Конструктор за копиране се извиква и при подаване на обекти като параметри на функция и при връщане на обекти от функция.

### Конструктор за копиране и динамична памет

Разгледайте следния клас:
```c++
class Person
{
    char *name;

public:
    Person(const char* Name = "Anonymous") 
    {
        int length = strlen(Name);
        name = new char[length + 1]; //+ 1 for '\0'
        strcpy(name, Name);
    }

    const char* getName() const 
    {
        return name;
    }

    void setName(const char* newName) 
    {
        if(name != nullptr) 
        {
            delete[] name;
        }
        int length = strlen(newName);
        name = new char[length + 1]; //+ 1 for '\0'
        strcpy(name, newName);
    }
};
```

За така дефиниран клас какво ще се изведе при изпълнението на следния код:

```c++
    Person a;
    Person b = a;

    std::cout << a.getName() << '\n';

    b.setName("NewName");
    
    std::cout << a.getName() << '\n';
    std::cout << b.getName() << '\n';
```

Поради тази причина трябва да се напише конструктор за копиране, който няма просто да копира член-данните. 
Пример:
```c++
    Person(const Person& copyFrom)
    {
        int length = strlen(copyFrom.getName());
        name = new char[length + 1]; //+ 1 for '\0'
        strcpy(name, copyFrom.getName());
    }
```

### Конструктори с точно един параметър
Специален тип конструктори. Където се очаква обект от някой клас `A`, но се подава обект от друг клас (или стойност от вграден тип) `B` и има дефиниран конструктор на `A` с един параметър от тип `B`, тогава този конструктор се извиква с подадения обект (или стойност от вграден тип) като аргумент. 
Пример:
```c++
    class Example {
    public:
        int a;
        int b;

        Example(int A) : a(A), b(100) {} 
    };

    void foo(Example obj) 
    {
        std::cout << obj.a << " " << obj.b << '\n';
    }

    int main()
    {
        foo(3);

        return 0;
    }
```
Този фрагмент код ще изведе ``3 100\n``. 
При извикването на `foo(3)` се създава обект от тип `Example` с помощта на конструктора с един параметър от тип `int`, на който му се подава числото `3`.

### Временни обекти
С помощта на конструкторите могат да се създават обекти, които се използват веднага и след използването им се унищожават.
Пример:
```c++
    Rational(1, 10).print();
```
Тук се създава анонимен обект, извиква се функцията `print()` чрез него и щом приключи изпълнението обекта се унищожава. 

### Обекти като член-данни на други класове
Възможно е член-данни в някой клас да са от тип някой друг клас.
При създаване на обект, който има член-данни от тип някой друг клас, с конструктор с параметри, трябва да се извика конструктора за копиране в *member initializer list*, иначе ще се извика конструктора по подразбиране. Защо?

Пример:
```c++
class Factory {
    Person boss;
    int numberOfEmployees;

public:
    Factory(const Person& Boss) : boss(Boss), numberOfEmployees(0) {}
};
```

Автоматично генерираният конструктор за копиране извиква конструкторите за копиране на обектите член-данни. Ако се дефинира конструктор за копиране, конструкторите за копиране на обектите член-данни трябва да се извикат експлицитно.

# Деструктори
Деструктора се грижи да се освободи паметта заделена за обекта, когато приключи неговият жизнен цикъл. Например, при излизане от областта, където е дефиниран или при извикване на `delete` (`delete[]`).

Ако не е дефиниран деструктор, той се автоматично създава.

Понякога при създаването на обект или по време на неговия жизнен цикъл се налага да заделяме ресурси, които не са "част от него" (заделяне на динамична памет, отваряне на файл, мрежова връзка...). Следователно, автоматично генерираният деструктор ще изтрие данните за обекта, обаче външните ресурси, които сме заделили ще останат. Затова се налага да си дефинираме деструктор, който ще се грижи ресурсите, които сме заделили, да се освобождават при приключването на жизнения цикъл на обекта.

В примера с класа `Person` заделяме динамична памет за `name`. При унищожаването на обекта (с автоматично дефиниран деструктор) ще се изтрие из паметта указателят `name`, но заделената памет, към която сочи, няма да се изтрие. Затова се налага да се дефинира деструктор, който да се погрижи за това.

```c++
~Person() 
{
    delete[] name;
}
```